# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

```bash
# Install dependencies
uv sync --locked --all-extras --dev

# Configure environment (includes COMPOSE_FILE for local development, see .env.example)
cp .env.example .env

# Start infrastructure (PostgreSQL, Redis, MinIO)
docker compose up -d postgres redis minio

# Create MinIO buckets, run migrations, and collect static files
docker compose up minio-create-buckets migrations collectstatic

# Run development server
make dev

# Run Celery worker
make celery-dev

# Manual database migrations (alternative to docker compose)
make makemigrations
make migrate

# Code quality
make format    # ruff format + fix
make lint      # ruff, ty, pyrefly, mypy
make test      # pytest with 80% coverage requirement
```

## Python Version

**Minimum Required:** Python 3.14+

This project leverages Python 3.14 features including:
- Deferred evaluation of annotations (PEP 649)
- Template string literals (PEP 750) - available for custom string processing
- Improved type inference and static analysis support

All code must be compatible with `mypy --strict` mode.

## Architecture Overview

This is a Django + Celery application using **punq** for dependency injection.

### Module Structure

- **`core/`** - Business logic, domain models, and **services**. All database operations are encapsulated in services.
- **`delivery/`** - External interfaces (HTTP API, Celery tasks). **Controllers NEVER access models directly.**
- **`infrastructure/`** - Cross-cutting concerns (JWT, auth, settings adapters, controller base classes).
- **`ioc/`** - Dependency injection container configuration.
- **`delivery/tasks/`** - Celery task definitions using controller pattern.

## Service Layer Architecture

**CRITICAL**: All new features must follow this pattern. Controllers must NEVER import or use Django models directly.

### The Golden Rule

```
Controller → Service → Model

✅ Controller imports Service
✅ Service imports Model
❌ Controller imports Model (NEVER)
```

### Correct Pattern

```python
# delivery/http/user/controllers.py
from core.user.services import UserService  # ✅ Import service, not model

class UserController(Controller):
    def __init__(self, user_service: UserService) -> None:
        self._user_service = user_service

    def get_user(self, request: HttpRequest, user_id: int) -> UserSchema:
        user = self._user_service.get_user_by_id(user_id)  # ✅ Use service
        return UserSchema.model_validate(user, from_attributes=True)
```

### Incorrect Pattern (NEVER DO THIS)

```python
# ❌ WRONG - Direct model import in controller
from core.user.models import User

class UserController(Controller):
    def get_user(self, request: HttpRequest, user_id: int) -> UserSchema:
        user = User.objects.get(id=user_id)  # ❌ Direct ORM access
        return UserSchema.model_validate(user, from_attributes=True)
```

### Creating Services

Services belong in `core/<domain>/services.py`:

```python
# core/item/services.py
from django.db import transaction
from core.item.models import Item

class ItemNotFoundError(Exception):
    """Domain exception for missing items."""

class ItemService:
    def get_item_by_id(self, item_id: int) -> Item:
        try:
            return Item.objects.get(id=item_id)
        except Item.DoesNotExist as e:
            raise ItemNotFoundError(f"Item {item_id} not found") from e

    def list_items(self) -> list[Item]:
        return list(Item.objects.all())

    @transaction.atomic
    def create_item(self, name: str, description: str) -> Item:
        return Item.objects.create(name=name, description=description)
```

### Registering Services

Register services in `src/ioc/registries/core.py`:

```python
container.register(ItemService, scope=Scope.singleton)
```

### Data Flow

```
HTTP Request → Controller → Service → Model → Database
                   ↓            ↓
              Pydantic      Domain
              Schemas     Exceptions
```

### Acceptable Exceptions

Direct model imports are acceptable ONLY in:
- **Django Admin** (`admin.py`) - Required for admin registration
- **Migrations** - Auto-generated by Django
- **Tests** - For creating test data with factories

### Entry Points

1. **HTTP API**: `src/manage.py` → `delivery/http/api.py` (Django-Ninja)
2. **Celery Worker**: `delivery/tasks/app.py`

All entry points share the same IoC container for consistent dependency resolution.

## IoC Container Pattern

The container is configured in `src/ioc/container.py`:

```python
def get_container() -> Container:
    container = Container()
    register_core(container)           # Settings, models, services
    register_infrastructure(container)  # JWT, auth, refresh sessions
    register_delivery(container)        # HTTP, bot, Celery controllers
    return container
```

### Registering Components

```python
# Type-based (auto-resolves dependencies from __init__ signature)
container.register(UserController, scope=Scope.singleton)

# Factory-based (for settings that load from env)
container.register(JWTServiceSettings, factory=lambda: JWTServiceSettings())

# Instance (for concrete implementations of abstract types)
container.register(type[BaseRefreshSession], instance=RefreshSession)
```

### Resolving Dependencies

```python
controller = container.resolve(UserController)
```

## Controller Pattern

Controllers are defined in `infrastructure/delivery/controllers.py`.

### Controller (HTTP API, Celery)

```python
class Controller(ABC):
    @abstractmethod
    def register(self, registry: Any) -> None: ...

    def handle_exception(self, exception: Exception) -> Any:
        raise exception  # Override for custom error handling
```

Controllers auto-wrap public methods with exception handling. Override `handle_exception()` to customize error responses.

### HTTP Controller Registration

```python
from infrastructure.django.auth import JWTAuthFactory

class UserController(Controller):
    def __init__(self, jwt_auth_factory: JWTAuthFactory) -> None:
        self._jwt_auth = jwt_auth_factory()

    def register(self, registry: Router) -> None:
        registry.add_api_operation(
            path="/v1/users/me",
            methods=["GET"],
            view_func=self.get_me,
            response=UserSchema,
            auth=self._jwt_auth,
        )
```

### JWT Authentication with Permissions

Use `JWTAuthFactory` for JWT authentication with optional permission checks:

```python
from infrastructure.django.auth import JWTAuthFactory

class AdminController(Controller):
    def __init__(self, jwt_auth_factory: JWTAuthFactory) -> None:
        self._jwt_auth = jwt_auth_factory()  # Basic auth
        self._staff_auth = jwt_auth_factory(require_staff=True)
        self._superuser_auth = jwt_auth_factory(require_superuser=True)

    def register(self, registry: Router) -> None:
        # Staff-only endpoint
        registry.add_api_operation(
            path="/v1/admin/reports",
            methods=["GET"],
            view_func=self.list_reports,
            auth=self._staff_auth,
        )
```

Parameters:
- `require_staff: bool = False` - If `True`, requires `user.is_staff=True`
- `require_superuser: bool = False` - If `True`, requires `user.is_superuser=True`

Permission denied returns `403 Forbidden` (not 401 - user is authenticated but not authorized).

### Celery Task Controller Registration

```python
class PingTaskController(Controller):
    def register(self, registry: Celery) -> None:
        registry.task(name=TaskName.PING)(self.ping)
```

## Testing Architecture

### Test Factories

Test factories in `tests/integration/factories.py` enable isolated testing with IoC override capability:

- **`TestClientFactory`** - Creates test clients with optional authentication
- **`TestUserFactory`** - Creates test users
- **`TestCeleryWorkerFactory`** - Manages test worker lifecycle
- **`TestTasksRegistryFactory`** - Creates task registry instances

### Per-Test Container Isolation

Each test gets a fresh container (function-scoped fixtures), enabling IoC overrides:

```python
@pytest.fixture(scope="function")
def container() -> Container:
    return get_container()

@pytest.fixture(scope="function")
def test_client_factory(api_factory: NinjaAPIFactory) -> TestClientFactory:
    # New API + test client per test function for IoC override capability
    return TestClientFactory(api_factory=api_factory)
```

### Overriding IoC Registrations in Tests

To mock a component for a specific test:

```python
def test_with_mock_service(container: Container) -> None:
    # Override before creating factories
    mock_service = MagicMock()
    container.register(JWTService, instance=mock_service)

    api_factory = NinjaAPIFactory(container=container)
    test_client = TestClientFactory(api_factory=api_factory)()
    # Now all requests use mock_service
```

### HTTP API Tests

```python
@pytest.mark.django_db(transaction=True)
def test_create_user(test_client_factory: TestClientFactory) -> None:
    test_client = test_client_factory()
    response = test_client.post("/v1/users/", json={...})
```

### Celery Task Tests

```python
def test_ping_task(celery_worker_factory: CeleryWorkerFactory, container: Container) -> None:
    registry = container.resolve(TasksRegistry)
    with celery_worker_factory():  # Starts worker in context
        result = registry.ping.delay().get(timeout=1)
```

## API Factory Customization

`get_ninja_api()` and `get_celery_app()` accept optional `container` parameter for test customization:

```python
def get_ninja_api(
    container: Container | None = None,  # Custom container for tests
    urls_namespace: str | None = None,   # Unique namespace per test
) -> NinjaAPI:
```

## Configuration

Uses Pydantic BaseSettings with environment variable prefixes:
- `DJANGO_` - Django settings (SECRET_KEY, DEBUG)
- `JWT_` - JWT configuration (SECRET_KEY, algorithm, expiry)
- `AWS_S3_` - S3/MinIO storage
- `CELERY_` - Celery settings

Settings classes are registered in IoC and injected into services.

## Test Environment

Tests use `.env.test` file loaded in `tests/conftest.py`. Required services:
- PostgreSQL (or SQLite for unit tests)
- Redis (for Celery tests)

## Code Quality & Best Practices

### Mandatory Requirements

All new code MUST adhere to these requirements:

1. **Follow Existing Patterns** - All new code MUST follow the exact patterns established in this codebase. Study existing implementations before writing new code. Do not introduce new architectural patterns without discussion.

2. **Type Safety** - All code must pass `mypy --strict`. Use precise type hints, avoid `Any` where possible. Leverage Python 3.14's improved type inference.

3. **Industry Best Practices** - Do not reinvent the wheel. Use established patterns:
   - Dependency injection via IoC container (punq)
   - Service layer for all database operations
   - Pydantic for validation and serialization
   - Factory pattern for testability
   - Domain exceptions for error handling

4. **Testing** - Maintain 80%+ code coverage. Use provided test factories. Write both unit and integration tests.

5. **Code Review Checklist**:
   - Does the code follow the Controller → Service → Model pattern?
   - Are all dependencies injected via IoC container?
   - Are there proper type hints on all functions?
   - Are domain exceptions used instead of generic ones?
   - Is the code tested with appropriate coverage?

### Code Style

- Run `make format` before committing (ruff format + fix)
- Run `make lint` to verify (ruff, ty, pyrefly, mypy)
- Prefer explicit over implicit
- Keep functions focused and small
- Use domain exceptions, not generic ones
- Follow PEP 8 naming conventions
- Write docstrings for public APIs using Google style

## Code Style Guidelines

### `__init__.py` Files

- **Do not write logic in `__init__.py` files** - Keep them empty or minimal
- **Avoid `__all__` declarations** - Do not use `__all__` to control exports
- **Exception**: Configuration code that must run before imports (e.g., Django setup) is allowed
- **Always ask for user confirmation** before adding any code to `__init__.py` files
