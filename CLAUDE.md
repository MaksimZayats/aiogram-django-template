# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

```bash
# Install dependencies
uv sync --locked --all-extras --dev

# Configure environment (includes COMPOSE_FILE for local development, see .env.example)
cp .env.example .env

# Start infrastructure (PostgreSQL, Redis, MinIO)
docker compose up -d postgres redis minio

# Create MinIO buckets, run migrations, and collect static files
docker compose up minio-create-buckets migrations collectstatic

# Run development server
make dev

# Run Celery worker
make celery-dev

# Manual database migrations (alternative to docker compose)
make makemigrations
make migrate

# Code quality
make format    # ruff format + fix
make lint      # ruff, ty, pyrefly, mypy
make test      # pytest with 80% coverage requirement
```

## Architecture Overview

This is a Django + aiogram + Celery application using **punq** for dependency injection.

### Module Structure

- **`core/`** - Business logic, domain models, and **services**. All database operations are encapsulated in services.
- **`delivery/`** - External interfaces (HTTP API, Telegram bot, Celery tasks). **Controllers NEVER access models directly.**
- **`infrastructure/`** - Cross-cutting concerns (JWT, auth, settings adapters, controller base classes).
- **`ioc/`** - Dependency injection container configuration.
- **`delivery/tasks/`** - Celery task definitions using controller pattern.

## Service Layer Architecture

**CRITICAL**: All new features must follow this pattern. Controllers must NEVER import or use Django models directly.

### The Golden Rule

```
Controller → Service → Model

✅ Controller imports Service
✅ Service imports Model
❌ Controller imports Model (NEVER)
```

### Correct Pattern

```python
# delivery/http/user/controllers.py
from core.user.services import UserService  # ✅ Import service, not model

class UserController(Controller):
    def __init__(self, user_service: UserService) -> None:
        self._user_service = user_service

    def get_user(self, request: HttpRequest, user_id: int) -> UserSchema:
        user = self._user_service.get_user_by_id(user_id)  # ✅ Use service
        return UserSchema.model_validate(user, from_attributes=True)
```

### Incorrect Pattern (NEVER DO THIS)

```python
# ❌ WRONG - Direct model import in controller
from core.user.models import User

class UserController(Controller):
    def get_user(self, request: HttpRequest, user_id: int) -> UserSchema:
        user = User.objects.get(id=user_id)  # ❌ Direct ORM access
        return UserSchema.model_validate(user, from_attributes=True)
```

### Creating Services

Services belong in `core/<domain>/services.py`:

```python
# core/item/services.py
from django.db import transaction
from core.item.models import Item

class ItemNotFoundError(Exception):
    """Domain exception for missing items."""

class ItemService:
    def get_item_by_id(self, item_id: int) -> Item:
        try:
            return Item.objects.get(id=item_id)
        except Item.DoesNotExist as e:
            raise ItemNotFoundError(f"Item {item_id} not found") from e

    def list_items(self) -> list[Item]:
        return list(Item.objects.all())

    @transaction.atomic
    def create_item(self, name: str, description: str) -> Item:
        return Item.objects.create(name=name, description=description)
```

### Registering Services

Register services in `src/ioc/registries/core.py`:

```python
container.register(ItemService, scope=Scope.singleton)
```

### Data Flow

```
HTTP Request → Controller → Service → Model → Database
                   ↓            ↓
              Pydantic      Domain
              Schemas     Exceptions
```

### Acceptable Exceptions

Direct model imports are acceptable ONLY in:
- **Django Admin** (`admin.py`) - Required for admin registration
- **Migrations** - Auto-generated by Django
- **Tests** - For creating test data with factories

### Entry Points

1. **HTTP API**: `src/manage.py` → `delivery/http/api.py` (Django-Ninja)
2. **Telegram Bot**: `delivery/bot/__main__.py` (aiogram polling)
3. **Celery Worker**: `delivery/tasks/app.py`

All entry points share the same IoC container for consistent dependency resolution.

## IoC Container Pattern

The container is configured in `src/ioc/container.py`:

```python
def get_container() -> Container:
    container = Container()
    _register_services(container)      # JWTService, RefreshSessionService
    _register_http(container)          # JWTAuth, NinjaAPI
    _register_controllers(container)   # HTTP controllers
    _register_celery(container)        # Task controllers
    _register_bot(container)           # Telegram bot controllers
    return container
```

### Registering Components

```python
# Type-based (auto-resolves dependencies from __init__ signature)
container.register(UserController, scope=Scope.singleton)

# Factory-based (for settings that load from env)
container.register(JWTServiceSettings, factory=lambda: JWTServiceSettings())

# Instance (for concrete implementations of abstract types)
container.register(type[BaseRefreshSession], instance=RefreshSession)
```

### Resolving Dependencies

```python
controller = container.resolve(UserController)
```

## Controller Pattern

Controllers are defined in `infrastructure/delivery/controllers.py`. There are two base classes:

### Sync Controller (HTTP API, Celery)

```python
class Controller(ABC):
    @abstractmethod
    def register(self, registry: Any) -> None: ...

    def handle_exception(self, exception: Exception) -> Any:
        raise exception  # Override for custom error handling
```

### Async Controller (Telegram Bot)

For async handlers (like aiogram), use `AsyncController`:

```python
class AsyncController(ABC):
    @abstractmethod
    def register(self, registry: Any) -> None: ...

    async def handle_exception(self, exception: Exception) -> Any:
        raise exception  # Override for custom error handling
```

Both controllers auto-wrap public methods with exception handling. Override `handle_exception()` to customize error responses.

### HTTP Controller Registration

```python
class UserController(Controller):
    def __init__(self, jwt_auth: JWTAuth) -> None:
        self._jwt_auth = jwt_auth

    def register(self, registry: Router) -> None:
        registry.add_api_operation(
            path="/v1/users/me",
            methods=["GET"],
            view_func=self.get_me,
            response=UserSchema,
            auth=self._jwt_auth,
        )
```

### Celery Task Controller Registration

```python
class PingTaskController(Controller):
    def register(self, registry: Celery) -> None:
        registry.task(name=TaskName.PING)(self.ping)
```

### Telegram Bot Controller Registration

```python
class CommandsController(AsyncController):
    def register(self, registry: Router) -> None:
        registry.message.register(
            self.handle_start_command,
            Command(commands=["start"]),
        )

    async def handle_start_command(self, message: Message) -> None:
        await message.answer("Hello!")
```

Bot controllers are registered in the IoC container and injected into `DispatcherFactory`:

```python
container.register(CommandsController, scope=Scope.singleton)
container.register(DispatcherFactory, scope=Scope.singleton)
container.register(
    Dispatcher,
    factory=lambda: container.resolve(DispatcherFactory)(),
    scope=Scope.singleton,
)
```

## Testing Architecture

### Test Factories

Test factories in `tests/integration/factories.py` enable isolated testing with IoC override capability:

- **`NinjaAPIFactory`** - Creates API instances with unique URL namespaces per test
- **`TestClientFactory`** - Wraps API factory to create test clients
- **`UserFactory`** - Creates test users
- **`CeleryAppFactory`** - Creates Celery apps with container
- **`CeleryWorkerFactory`** - Manages test worker lifecycle

### Per-Test Container Isolation

Each test gets a fresh container (function-scoped fixtures), enabling IoC overrides:

```python
@pytest.fixture(scope="function")
def container() -> Container:
    return get_container()

@pytest.fixture(scope="function")
def test_client_factory(api_factory: NinjaAPIFactory) -> TestClientFactory:
    # New API + test client per test function for IoC override capability
    return TestClientFactory(api_factory=api_factory)
```

### Overriding IoC Registrations in Tests

To mock a component for a specific test:

```python
def test_with_mock_service(container: Container) -> None:
    # Override before creating factories
    mock_service = MagicMock()
    container.register(JWTService, instance=mock_service)

    api_factory = NinjaAPIFactory(container=container)
    test_client = TestClientFactory(api_factory=api_factory)()
    # Now all requests use mock_service
```

### HTTP API Tests

```python
@pytest.mark.django_db(transaction=True)
def test_create_user(test_client_factory: TestClientFactory) -> None:
    test_client = test_client_factory()
    response = test_client.post("/v1/users/", json={...})
```

### Celery Task Tests

```python
def test_ping_task(celery_worker_factory: CeleryWorkerFactory, container: Container) -> None:
    registry = container.resolve(TasksRegistry)
    with celery_worker_factory():  # Starts worker in context
        result = registry.ping.delay().get(timeout=1)
```

## API Factory Customization

`get_ninja_api()` and `get_celery_app()` accept optional `container` parameter for test customization:

```python
def get_ninja_api(
    container: Container | None = None,  # Custom container for tests
    urls_namespace: str | None = None,   # Unique namespace per test
) -> NinjaAPI:
```

## Configuration

Uses Pydantic BaseSettings with environment variable prefixes:
- `DJANGO_` - Django settings (SECRET_KEY, DEBUG)
- `JWT_` - JWT configuration (SECRET_KEY, algorithm, expiry)
- `AWS_S3_` - S3/MinIO storage
- `TELEGRAM_BOT_` - Bot token
- `CELERY_` - Celery settings

Settings classes are registered in IoC and injected into services.

## Test Environment

Tests use `.env.test` file loaded in `tests/conftest.py`. Required services:
- PostgreSQL (or SQLite for unit tests)
- Redis (for Celery tests)

## Code Style Guidelines

### `__init__.py` Files

- **Do not write logic in `__init__.py` files** - Keep them empty or minimal
- **Avoid `__all__` declarations** - Do not use `__all__` to control exports
- **Exception**: Configuration code that must run before imports (e.g., Django setup) is allowed
- **Always ask for user confirmation** before adding any code to `__init__.py` files
