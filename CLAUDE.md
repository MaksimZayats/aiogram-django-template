# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

```bash
# Install dependencies
uv sync --locked --all-groups

# Configure environment (includes COMPOSE_FILE for local development, see .env.example)
cp .env.example .env

# Start infrastructure (PostgreSQL, Redis, MinIO)
docker compose up -d postgres redis minio minio-create-buckets

# Run migrations and collect static files
docker compose up migrations collectstatic

# Run development server
make dev

# Run Celery worker
make celery-dev

# Run Celery beat scheduler (for scheduled tasks)
make celery-beat-dev

# Manual database migrations (alternative to docker compose)
make makemigrations
make migrate

# Code quality
make format    # ruff format + fix
make lint      # ruff, ty, pyrefly, mypy
make test      # pytest with 80% coverage requirement

# Documentation
make docs      # Serve docs with live reload
make docs-build # Build static documentation
```

## Python Version

**Minimum Required:** Python 3.14+

The project requires Python 3.14+ and uses standard Python typing patterns including union operators (`|`), `Annotated`, and PEP 695 type parameters.

All code must be compatible with `mypy --strict` mode.

## Architecture Overview

This is a Django + Celery application using **punq** for dependency injection.

### Module Structure

- **`configs/`** - Application configuration (Django settings, logging, Pydantic settings classes).
- **`core/`** - Business logic, domain models, and **services**. All database operations are encapsulated in services.
- **`delivery/`** - External interfaces (HTTP API, Celery tasks, JWT auth, delivery-specific services). **Controllers NEVER access models directly.**
- **`infrastructure/`** - Cross-cutting concerns (settings adapters, controller base classes, telemetry).
- **`ioc/`** - Dependency injection container configuration.
- **`delivery/tasks/`** - Celery task definitions using controller pattern.

## Service Layer Architecture

**CRITICAL**: All new features must follow this pattern. Controllers must NEVER import or use Django models directly.

### The Golden Rule

```
Controller → Service → Model

✅ Controller imports Service
✅ Service imports Model
❌ Controller imports Model (NEVER)
```

### Correct Pattern

```python
# delivery/http/user/controllers.py
from core.user.services.user import UserService  # ✅ Import service, not model

class UserController(Controller):
    def __init__(self, user_service: UserService) -> None:
        self._user_service = user_service

    def get_user(self, request: HttpRequest, user_id: int) -> UserSchema:
        user = self._user_service.get_user_by_id(user_id)  # ✅ Use service
        return UserSchema.model_validate(user, from_attributes=True)
```

### Incorrect Pattern (NEVER DO THIS)

```python
# ❌ WRONG - Direct model import in controller
from core.user.models import User

class UserController(Controller):
    def get_user(self, request: HttpRequest, user_id: int) -> UserSchema:
        user = User.objects.get(id=user_id)  # ❌ Direct ORM access
        return UserSchema.model_validate(user, from_attributes=True)
```

### Creating Services

Services belong in `core/<domain>/services.py` or `core/<domain>/services/<service_name>.py` for domains with multiple services:

```python
# core/item/services.py
from django.db import transaction
from core.item.models import Item

class ItemNotFoundError(Exception):
    """Domain exception for missing items."""

class ItemService:
    def get_item_by_id(self, item_id: int) -> Item:
        try:
            return Item.objects.get(id=item_id)
        except Item.DoesNotExist as e:
            raise ItemNotFoundError(f"Item {item_id} not found") from e

    def list_items(self) -> list[Item]:
        return list(Item.objects.all())

    @transaction.atomic
    def create_item(self, name: str, description: str) -> Item:
        return Item.objects.create(name=name, description=description)
```

### Registering Services

Services are **auto-registered** by the IoC container - no explicit registration needed. When a service is resolved, the `AutoRegisteringContainer` automatically registers it as a singleton based on its `__init__` type annotations.

```python
# No registration needed - just resolve the service
item_service = container.resolve(ItemService)  # Auto-registered as singleton
```

Only protocol/interface mappings require explicit registration in `src/ioc/registries.py`.

### Data Flow

```
HTTP Request → Controller → Service → Model → Database
                   ↓            ↓
              Pydantic      Domain
              Schemas     Exceptions
```

### Acceptable Exceptions

Direct model imports are acceptable ONLY in:
- **Django Admin** (`admin.py`) - Required for admin registration
- **Migrations** - Auto-generated by Django
- **Tests** - For creating test data with factories

### Entry Points

1. **HTTP API**: `delivery/http/app.py` (FastAPI)
2. **Celery Worker**: `delivery/tasks/app.py`

All entry points share the same IoC container for consistent dependency resolution.

## IoC Container Pattern

The container uses **auto-registration** - services are automatically registered when resolved based on their `__init__` type annotations.

### Container Setup

The container is created via `ContainerFactory` in `src/ioc/container.py`:

```python
from ioc.container import ContainerFactory

container_factory = ContainerFactory()
container = container_factory()  # Creates AutoRegisteringContainer
```

### AutoRegisteringContainer

The `AutoRegisteringContainer` automatically registers services when resolved:

```python
# No explicit registration needed - just resolve
user_service = container.resolve(UserService)  # Auto-registered as singleton

# Pydantic Settings are auto-detected and registered with factory
jwt_settings = container.resolve(JWTServiceSettings)  # Loads from env vars
```

The container:
1. Inspects `__init__` type annotations
2. Auto-registers Pydantic Settings with `factory=lambda: SettingsClass()`
3. Auto-registers other classes as singletons
4. Recursively registers dependencies

### Explicit Registration (Special Cases Only)

Explicit registration in `src/ioc/registries.py` is needed for:
- Protocol/interface mappings
- Special factory classes resolved by string key

```python
class Registry:
    def register(self, container: Container) -> None:
        # Factory class resolved by string key
        container.register(
            "FastAPIFactory",
            factory=lambda: container.resolve(FastAPIFactory),
            scope=Scope.singleton,
        )
        # Protocol to concrete implementation mapping
        container.register(
            ApplicationSettingsProtocol,
            factory=lambda: container.resolve(ApplicationSettings),
            scope=Scope.singleton,
        )
```

### Resolving Dependencies

```python
# The entire dependency graph is auto-resolved
controller = container.resolve(UserController)
# UserController -> UserService -> (auto-registered)
# UserController -> JWTAuthFactory -> JWTService -> JWTServiceSettings (auto from env)
```

## Controller Pattern

Controllers are defined in `infrastructure/delivery/controllers.py`.

### Controller (HTTP API, Celery)

```python
class Controller(ABC):
    @abstractmethod
    def register(self, registry: Any) -> None: ...

    def handle_exception(self, exception: Exception) -> Any:
        raise exception  # Override for custom error handling
```

Controllers auto-wrap public methods with exception handling. Override `handle_exception()` to customize error responses.

### Sync vs Async Handlers

**Always use synchronous handler methods.** FastAPI automatically runs sync handlers in a thread pool using `anyio.to_thread.run_sync()`, providing proper parallelism for Django's synchronous ORM.

```python
# ✅ CORRECT - Sync handler (recommended)
def get_user(self, request: AuthenticatedRequest, user_id: int) -> UserSchema:
    user = self._user_service.get_user_by_id(user_id)
    return UserSchema.model_validate(user, from_attributes=True)

# ❌ WRONG - Async handler calling sync service directly (blocks event loop)
async def get_user(self, request: AuthenticatedRequest, user_id: int) -> UserSchema:
    user = self._user_service.get_user_by_id(user_id)  # Blocks the event loop!
    return UserSchema.model_validate(user, from_attributes=True)
```

**Thread pool configuration:** Control parallelism via `ANYIO_THREAD_LIMITER_TOKENS` environment variable (default: 40 concurrent threads per worker). See `src/infrastructure/anyio/configurator.py`.

### Async Handlers (Advanced)

In rare cases where you need async handlers (e.g., calling external async APIs), use `asgiref.sync_to_async` to call services:

```python
from asgiref.sync import sync_to_async

async def get_user_async(self, request: AuthenticatedRequest, user_id: int) -> UserSchema:
    # thread_sensitive=False for read-only operations (parallel execution)
    user = await sync_to_async(
        self._user_service.get_user_by_id,
        thread_sensitive=False,
    )(user_id)
    return UserSchema.model_validate(user, from_attributes=True)

async def create_user_async(self, request: AuthenticatedRequest, body: CreateUserRequest) -> UserSchema:
    # thread_sensitive=True for write operations (transaction safety)
    user = await sync_to_async(
        self._user_service.create_user,
        thread_sensitive=True,
    )(**body.model_dump())
    return UserSchema.model_validate(user, from_attributes=True)
```

**Thread sensitivity rules:**
- `thread_sensitive=False` - Read-only operations (SELECT) - allows parallel execution
- `thread_sensitive=True` - Write operations (INSERT/UPDATE/DELETE) - ensures transaction safety

### HTTP Controller Registration

```python
from dataclasses import dataclass, field
from fastapi import APIRouter, Depends
from delivery.http.auth.jwt import JWTAuth, JWTAuthFactory

@dataclass
class UserController(Controller):
    _jwt_auth_factory: JWTAuthFactory
    _jwt_auth: JWTAuth = field(init=False)

    def __post_init__(self) -> None:
        self._jwt_auth = self._jwt_auth_factory()

    def register(self, registry: APIRouter) -> None:
        registry.add_api_route(
            path="/v1/users/me",
            endpoint=self.get_me,
            methods=["GET"],
            response_model=UserSchema,
            dependencies=[Depends(self._jwt_auth)],
        )
```

### JWT Authentication with Permissions

Use `JWTAuthFactory` for JWT authentication with optional permission checks:

```python
from dataclasses import dataclass, field
from fastapi import APIRouter, Depends
from delivery.http.auth.jwt import JWTAuth, JWTAuthFactory

@dataclass
class AdminController(Controller):
    _jwt_auth_factory: JWTAuthFactory
    _jwt_auth: JWTAuth = field(init=False)
    _staff_auth: JWTAuth = field(init=False)
    _superuser_auth: JWTAuth = field(init=False)

    def __post_init__(self) -> None:
        self._jwt_auth = self._jwt_auth_factory()  # Basic auth
        self._staff_auth = self._jwt_auth_factory(require_staff=True)
        self._superuser_auth = self._jwt_auth_factory(require_superuser=True)

    def register(self, registry: APIRouter) -> None:
        # Staff-only endpoint
        registry.add_api_route(
            path="/v1/admin/reports",
            endpoint=self.list_reports,
            methods=["GET"],
            dependencies=[Depends(self._staff_auth)],
        )
```

Parameters:
- `require_staff: bool = False` - If `True`, requires `user.is_staff=True`
- `require_superuser: bool = False` - If `True`, requires `user.is_superuser=True`

Permission denied returns `403 Forbidden` (not 401 - user is authenticated but not authorized).

### Celery Task Controller Registration

```python
class PingTaskController(Controller):
    def register(self, registry: Celery) -> None:
        registry.task(name=TaskName.PING)(self.ping)
```

## Testing Architecture

### Test Factories

Test factories in `tests/integration/factories.py` are container-based and enable isolated testing:

- **`TestClientFactory`** - Creates FastAPI `TestClient` with optional authentication
- **`TestUserFactory`** - Creates test users via the User model
- **`TestCeleryWorkerFactory`** - Manages Celery worker lifecycle as context manager
- **`TestTasksRegistryFactory`** - Creates task registry instances

All factories extend `ContainerBasedFactory` and receive the container via constructor:

```python
class ContainerBasedFactory(BaseFactory, ABC):
    def __init__(self, container: AutoRegisteringContainer) -> None:
        self._container = container
```

### Per-Test Container Isolation

Each test gets a fresh container (function-scoped fixtures in `tests/integration/conftest.py`):

```python
@pytest.fixture(scope="function")
def container() -> AutoRegisteringContainer:
    container_factory = ContainerFactory()
    return container_factory()

@pytest.fixture(scope="function")
def test_client_factory(container: AutoRegisteringContainer) -> TestClientFactory:
    return TestClientFactory(container=container)

@pytest.fixture(scope="function")
def user_factory(
    transactional_db: None,
    container: AutoRegisteringContainer,
) -> TestUserFactory:
    return TestUserFactory(container=container)
```

### HTTP API Tests

Use class-based tests with `@pytest.mark.django_db(transaction=True)`:

```python
@pytest.fixture(scope="function")
def user(user_factory: TestUserFactory) -> User:
    return user_factory(username="test", password="test-password")

@pytest.mark.django_db(transaction=True)
class TestUserController:
    def test_create_user(self, test_client_factory: TestClientFactory) -> None:
        with test_client_factory() as test_client:
            response = test_client.post(
                "/v1/users/",
                json={"username": "new_user", "email": "user@test.com", "password": "pass"},
            )

        assert response.status_code == HTTPStatus.OK

    def test_authenticated_endpoint(
        self,
        test_client_factory: TestClientFactory,
        user: User,
    ) -> None:
        # Use auth_for_user to auto-inject JWT token
        with test_client_factory(auth_for_user=user) as test_client:
            response = test_client.get("/v1/users/me")

        assert response.status_code == HTTPStatus.OK
```

### Celery Task Tests

Use `TestTasksRegistryFactory` to get the registry and `TestCeleryWorkerFactory` as context manager:

```python
class TestPingTaskController:
    def test_ping_task(
        self,
        celery_worker_factory: TestCeleryWorkerFactory,
        tasks_registry_factory: TestTasksRegistryFactory,
    ) -> None:
        registry = tasks_registry_factory()
        with celery_worker_factory():  # Starts worker in context
            ping_result = registry.ping.delay().get(timeout=1)

        assert ping_result == PingResult(result="pong")
```

### Overriding IoC Registrations in Tests

To mock a component, register it on the container before creating factories:

```python
def test_with_mock_service(container: AutoRegisteringContainer) -> None:
    # Override before creating test client
    mock_service = MagicMock()
    container.register(JWTService, instance=mock_service)

    test_client_factory = TestClientFactory(container=container)
    with test_client_factory() as test_client:
        # Now all requests use mock_service
        response = test_client.get("/v1/some-endpoint")

    assert response.status_code == 200
```

## Configuration

Uses Pydantic BaseSettings with environment variable prefixes:
- `DJANGO_` - Django settings (SECRET_KEY, DEBUG)
- `JWT_` - JWT configuration (SECRET_KEY, algorithm, expiry)
- `AWS_S3_` - S3/MinIO storage
- `CELERY_` - Celery settings
- `ANYIO_` - Thread pool settings (THREAD_LIMITER_TOKENS for parallelism)
- `LOGGING_` - Logging level configuration
- `LOGFIRE_` - OpenTelemetry Logfire instrumentation (enabled, token)
- `INSTRUMENTOR_` - FastAPI instrumentation settings
- `CORS_` - CORS configuration (allow_credentials, allow_origins, allow_methods, allow_headers)

Unprefixed variables: `DATABASE_URL`, `REDIS_URL`, `ENVIRONMENT`, `ALLOWED_HOSTS`, `CSRF_TRUSTED_ORIGINS`

Settings classes are auto-registered in IoC and injected into services.

## Test Environment

Tests use `.env.test` file loaded in `tests/conftest.py`. Required services:
- PostgreSQL (or SQLite for unit tests)
- Redis (for Celery tests)

## Code Quality & Best Practices

### Mandatory Requirements

All new code MUST adhere to these requirements:

1. **Follow Existing Patterns** - All new code MUST follow the exact patterns established in this codebase. Study existing implementations before writing new code. Do not introduce new architectural patterns without discussion.

2. **Type Safety** - All code must pass `mypy --strict`. Use precise type hints, avoid `Any` where possible. Leverage Python 3.14's improved type inference.

3. **Industry Best Practices** - Do not reinvent the wheel. Use established patterns:
   - Dependency injection via IoC container (punq)
   - Service layer for all database operations
   - Pydantic for validation and serialization
   - Factory pattern for testability
   - Domain exceptions for error handling

4. **Testing** - Maintain 80%+ code coverage. Use provided test factories. Write both unit and integration tests.

5. **Code Review Checklist**:
   - Does the code follow the Controller → Service → Model pattern?
   - Are all dependencies injected via IoC container?
   - Are there proper type hints on all functions?
   - Are domain exceptions used instead of generic ones?
   - Is the code tested with appropriate coverage?

### Code Style

- Run `make format` before committing (ruff format + fix)
- Run `make lint` to verify (ruff, ty, pyrefly, mypy)
- Prefer explicit over implicit
- Keep functions focused and small
- Use domain exceptions, not generic ones
- Follow PEP 8 naming conventions
- Write docstrings for public APIs using Google style

## Code Style Guidelines

### `__init__.py` Files

- **Do not write logic in `__init__.py` files** - Keep them empty or minimal
- **Avoid `__all__` declarations** - Do not use `__all__` to control exports
- **Exception**: Configuration code that must run before imports (e.g., Django setup) is allowed
- **Always ask for user confirmation** before adding any code to `__init__.py` files
